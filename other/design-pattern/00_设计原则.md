# 设计原则

## Single Responsibility Priciple(单一职责原则)

- 就一个类而言，应该仅有一个引起它变化的原因，最好一个责任只指派给一个类
- 两个完全不一样的功能不应该放到一个类中，一个类中应该是一组相关性很高的函数，数据的封装
- 示例：[fresco的imagePipeline的结构](https://www.fresco-cn.org/docs/intro-image-pipeline.html)

## Open Close Priciple(开闭原则)

- 软件中的对象(类，模块，函数)应当对拓展是开放的，对修改是关闭的
- 应当尽量能过拓展的方式来实现变化，而不是通过修改已有的代码来实现
- 示例：ViewGroup和它的子类

## Liskov Substitution Priciple(里氏替换原则)

- 所有引用基类的地方必须能够使用其子类的对象，反过来，使用子类的地方，父类未必能够适应
- 里氏替换原则总结起来就是建立抽象，通过抽象建立规范，具体的实现在运行时替换掉抽象，保持系统的
 拓展性和灵活性
- 示例：List与ArrayList

## Dependence Inversion Principle(依赖倒置原则)

- 高层模块不应该依赖低层模块，两者都应该依赖抽象
- 抽象不应该依赖细节
- 细节应该依赖抽象
- 模块间的依赖能过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口和抽象类产生的
- **主要在于避免使用具体类，而使用抽象，可以是接口，也可是基类，也可以是抽象类**

## InterfaceSegregation Principle(接口隔离原则)

- 客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上
- 接口隔离原则的目的是系统解开耦合，从而容易修改，重构
- **问题**：class B extends A implements I，class D extends C implements I, 如果接口I对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。
- **解决方法**：将臃肿的接口I拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系
- **示例**：比如android中的onClick, onLongClick，onTouchEvent分离开来(PerformClick)

## Law of Demeter（迪米特原则／最少知识原则）

- Only talk to your immedate friends,只和直接的朋友通信
- 一个对象应该对其它对象有最小的了解
- 一个类应该对自己需要解耦或调用的类知道得最少，类的内部如何实现与调用或者依赖关系，调用者或者
 依赖者只需要知道它需要的方法即可，其它的一律不用管
- 类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大

## 其它设计准则

- 封装变化（策略模式）
- 多用组合少用继承
    - 类继承，与方法调用不同，继承打破了封装性
    - 导致子类脆弱的一个原因，就是我们在重写超类的方法时，**依赖于我们对于超类方法实现细节的了解**