# Copy control

## 拷贝构造函数

- 第一个参数是自身类类型对象的引用（常用const修饰），且任何额外参数都有默认值的构造函数称为拷贝构造函数，
- 拷贝构造函数通常不应当是explicit的

## 合成拷贝构造函数

- 类成员调用拷贝构造函数
- 内置类型的成员则直接拷贝
- 数组逐一拷贝每一个元素

## 拷贝构造函数的使用场景

- 拷贝初始化

```c++
string dots(10,'a');   // 直接初始化
string s(dots);        // 直接初始化
string s2 = dots;      // 拷贝初始化
string null_book = "9-999-999";   // 拷贝初始化
string nines = string(100, '9');  // 拷贝初始化
```

- 以下其它情况也会发生拷贝初始化：
    - 将一个对象作为实参传递给一个非引用类型的形参
    - 从一个返回类型为非引用类型的函数返回一个对象
    - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

- 如果转换构造函数是explicit，使用拷贝构造函数和直接初始化是有区别的

```c++
vector<int> v1(10);
vector<int> v2 =10 ;          //错误，explicit
void f(vector<int>);
f(10);                        //错误，explicit
f(vector<int>(10));
```

## 拷贝赋值运算符

- 赋值操作符也返回对同一类类型的引用。

```c++
 class Sales_item
    {
     public:
         // other members as before
         // equivalent to the synthesized assignment operator
         Sales_item& operator=(const Sales_item &);
    };
```

- **拷贝构造函数和赋值操作符基本一起使用，要么两者都不用自己定义，用自动生成的合成版本，要么两者都自己定义**

## 析构函数

- **构造函数先初始化再执行构造函数的函数体，而对于析构函数先执行函数体，再销毁成员。**
- 析构函数的成员销毁取决于类型，**类类型调用其析构函数，内置类型没有析构函数，隐式销毁一个内置指针类型的成员不会delete它所指向的对象，因而在析构函数中要手动delete指针所指向的对象**。
- 智能指针是类类型，因而具有析构函数。
- **变量在超出作用域时应该自动销毁，当对象的引用或指针超出作用域时，不会运行析构函数**。
- 许多类不需要显式析构函数，尤其是具有构造函数的类不一定需要定义自己的析构函数。仅在有些工作需要析构函数完成时，才需要析构函数。析构函数通常用于释放在构造函数或在对象生命期内获取的资源。

### 三/五法则

- **若一个类需要析构函数，则代表其合成的析构函数不足以释放类所拥有的资源，其中最典型的就是指针成员，析构时需要手动去释放指针指向的内存**，若存在自定义（且正确）的析构函数，但使用合成的拷贝构造函数，那么拷贝过去的也只是指针，此时两个对象的指针变量同时指向同一块内存，指向同一块内存的后果很有可能是在两个对象中的析构函数中先后被释放两次。所以需要额外的拷贝控制函数去控制相应资源的拷贝。**一个对象拥有额外的资源（指针指向的内存），但另一个对象使用合成的拷贝构造函数也同时拥有这块资源。当一方对象被销毁后，析构函数释放了资源，这时另一个对象便失去了这块资源（但程序员还不知道）**
- 行为像指针，自定义拷贝构造函数与拷贝赋值运算符，拷贝指针本身而不是对象，自定义析构函数时特别要注意不能单方面的释放资源，只有当最后一个用到资源的对象销毁时，才能释放资源。
- **如果类需要自定义析构函数，则它也需要自定义赋值操作符和复制构造函数**，这是一个有用的经验法则。这个规则常称为三/五法则。
- 对象的拷贝构造函数与拷贝赋值运算符基本上是成对出现的，但是有自定义的这两个函数，不一定需要自定义析构函数,可以使用 = default要求编译器生成合成版本的默认构造函数，拷贝构造函数，析构函数，拷贝赋值运算符

### 阻止拷贝

- C++11以前，**通过将拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝**，但是友元和成员函数可以调用拷贝函数，**为了阻止友员和成员函数的拷贝，将拷贝成员声明为private的，但是不定义它们**
- **阻止拷贝,就是将拷贝函数与拷贝赋值运算符定义为删除的函数**，常见的阻止拷贝的类有iostream
- delete可以应用于任何函数，但是主要用来阻止拷贝控制成员

```c++
struct NoCopy
{
    NoCopy() = default;
    NoCopy(const NoCopy&) =delete;
    NoCopy& operator=(const NoCopy&) = delete;
}
```

- **析构函数不能是删除的函数**，如果析构函数是删除的函数，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象
- **如果一个类有数据成员不能默认构造，拷贝，复制或者销毁，对应的默认构造，拷贝，复制或者销毁成员函数就被定义为删除的**
- 对于具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数函数
- **如果一个类有const成员，它不能使用合成的拷贝赋值运算符（const不能赋值）**
- **有引用成员的类，合成拷贝赋值运算符被定义为删除的**

## 管理类外资源

- **管理类外资源的类必须定义拷贝控制成员，也必须定义析构函数来释放对象分配的资源**，定义拷贝操作时，可以使类的行为像一个值或者一个指针。

### 行为像值

- 行为像值，它有自己的状态，**当拷贝一个像值的对象时，副本和原对象是完全独立的**。 对于如下的类需要做的事如下：

```c++
class HasPtr
{
public:
    HasPtr(const std::string &= std::string()):
        ps(new std::string(s),i(0)) {}
    HasPtr(const HasPtr &p):
        ps(new std::string(*p.ps)),i(p.i){}
    HasPtr& operator = (const HasPtr &);
    ~HasPtr() {delete ps;}
​
private:
    std::string *ps;
    int i;
}
```

- **拷贝复制运算符，正确的做法是先拷贝右侧运算对象，以处理自赋值情况**，防止自赋值时自身资源被释放无法再赋值给新资源。然后释放左侧运算对象资源，再更新左侧的资源

```c++
HasPtr& HasPtr::operator= (const HasPtr& rhs)
{
    auto newp = new string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```