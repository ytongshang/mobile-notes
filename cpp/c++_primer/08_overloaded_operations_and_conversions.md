# Overloaded Operations

## 运算符重载

- **重载运算符，如果为成员函数时，this绑定到左侧运算对象**
- **除了重载函数调用运算符operator()外，其他重运算符不能有默认参数**
- 不能重载的运算符有：逻辑与，逻辑或，逗号和取地址运算符

## 成员函数VS非成员函数

- 赋值（=）、下标（[])、调用(())和成员访问箭头（->）必须为成员
- 复合赋值一般来说为成员，但并非必须
- 改变对象状态的运算符或与给定类型密切相关的运算符，如递增、递减、解引用为成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系、位运算，为普通的非成员，如果将其定义为一个成员函数，则其左侧对象必须为一个类的对象

## 输入输出运算符

### 输出运算符

- **输出输出运算符必须是普通的非成员函数，一般很有可能要用到对象的私有成员，一般将其定义为friend函数**
- 输出运算符第一个形参是一个非常量ostream对象的引用，非常量为写入会改变其状态，引用因为无法复制ostream对象,输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符

```c++
ostream& operator<<(ostream& os,const T& item)
{
    os<<...<<...<<...;
    return os;
}
```

### 输入运算符

- 输入运算符的第一个形参是运算符将要读取的流的引用 ，第二个形参是将要读入到的（非常量）
- **输入运算符必理输入可能失败的情况，而输出运算符不需要**
- 当流含有错误类型的数据，或者读取到了文件的末尾都会了生错误，当错误发生时，是在读取了所有数据后赶在使用这些数据据前一次性检查
- 当读取操作符发生错误时，输入运算符应该负责从错误中恢复

```c++
istream& operator>>(istream& is, Sales_data& item)
{
    double price;
    is>>item.bookNo>>item.units_sold>>price;
    if(is)
        item.revenue = item.units_sold*price;
    else
        item = Sales_data();
    return is;
}
```

## 算术运算符

- 算术运算符通常会计算它的两个运算对象并得到一个新值，**这个值有别于任何一个运算对象，常常位于一个局部变量内**，操作完成后返回该局部变量的副本作为结果
- 定义了算术运算符也会定义对应的复合赋值运算符
- 同时定义了算术运算符和复活赋值运算符，应当使用复合赋值来实现算术运算符
- **算术运算不能返回引用，因为结果是局部变量，不能返回局部变量的引用或者指针**

```c++
Sales_data operator+(const Sales_data& lhs,const Sales_data& rhs)
{
    Sales_data sum = lhs;
    sum += rhs;
    return sum;
}
```

## 相等以及关系运算符

- **对于类一般会定义==运算符**，这样做有利于使用标准库算法来处理这个类
- 定义了==运算符，这个类也应当定义！=，当然一般是定义==，然后定义！= 时调用==
- 对于关系运算符一般选择定义<运算符，并且只有存在一种唯一一种逻辑可靠的<定义才会选择定义，如果类同时还包含==，只有当==产生的结果和<一样时才定义

## 赋值运算符

- 赋值运算符除了拷贝赋值和移动赋值运算符，常见的还有C++11新增的initializer_list<T>,用一个T元素的list去初始化
- 赋值所要实现的动作，要考虑自赋值问题，因而要做的一般是先拷贝右侧对象，然后释放左侧对象的资源，然后将拷贝的临时对象赋值给左侧对象，在这其中又用到了拷贝赋值和移动赋值运算符
- 无论赋值还是复合赋值运算符，函数返回的都是左侧对象的引用，并且赋值运算一般都会被定义为成员函数

## 下标运算符

- 下标运算符必须是成员函数
- 如果一个类重载了下标运算符，**一般会定义两个版本，一个返回普通引用，另一个是常量成员函数，并返回常量成员，
- 如果重载下标运算符比较复杂，而且两个版本内容基本一致，最好的办法是先定义const版本，然后在非const版本里调用const版本

```c++
class TextBlock
{
public:
    const char& operator[](std::size_t postion)const
    {
        ...
    }
    char& operator[](std::size_t positon)
    {
     return  const_cast<char&>(static_cast<const TextBlock&>(*this)[position]);
    }
}
```

## 自增自减运算符

- 在迭代器会经常实现++，--
- 虽然自增自减运算符没有要求一定为成员函数，但是因为其改变了所操作对象的状态，所以一般定义为成员函数
- **前置版本返回递增或递减后对象的引用，后置版本返回对象的原值，返回的形式是一个值而不是引用**
- 为了区分前置版本与后置版本，**一般为后置版本显式定义一个int的形参**，但该形参不会参与到重载的实现，仅为了与前置版本形成重载
- **一般先定义前置版本，后置版本会调用前置版本**

```c++
// 定义前置版本时，一般要判断++是否会超过末尾，--是否会在开头以前
StrBlobPtr& StrBlobPtr::opetator++()
{
    check(curr,"increment past end of StrBlobPtr");
    ++curr;
    return *this;
}
​
StrBlobPtr StrBlobPtr::operator++(int)
{
    // 后置版本调用前置版本
    StrBlobPtr ret = *this;
    ++*this;
    return ret;
}
// 显示调用后置运算符
StrBlobPtr p(a1);
p.operator++(0);     //后置版本
p.operator++();      //前置版本
```

## 成员访问运算符

- 在迭代器和智能指针类一般会实现解引用与就箭头运算符
- 箭头必须是成员函数，解引用一般也定义为成员函数
- **两个函数一般定义为 const成员函数，但是返回的是非常量的引用与指针**
- 箭头运算符永远不能丢掉成员访问这个最基本的含义

```c++
point->mem ;
//point必须指向类对象的指针或者重载了operator->的类的对象
//则其分别等价于
（*point）.mem;
point.operator()->mem;
```

## 函数调用运算符

- 也就是STL中的仿函数

## 重载、类型转换与运算符

- 类型转换运算符不能有任何参数，不能显式的指定返回类型，实际上是返回一个对应类型的值，且必须定义为成员函数
- 定义的格式为：  operator type() const; 其中type为返回的类型，type不能是void类型，**因而不能返回函数与数组类型，但是可以返回函数指针与数组指针类型**

```c++
class SmallInt
{
public:
    SmallInt(int i = 0):val(i)
    {
        if(i<0||i>255)
            throw std::out_of_range("Bad SmallInt value");
    }
    operator int() const
    {
        return val;
    }
private:
    std::size_t val;
}
```

- 类型转换运算符比较少见，其中最常见的是定义向bool类型转换的类型转换函数

```c++
int i= 12;
cin<<i;
//虽然cin没有定义<<,但是上述运算可以看作一个关系比较运算，编译是合法的
```

- c++11引入了显式的类型转换运算符

```c++
class SmallInt
{
public:
    explicit operator int() const {return val;}
};

// 在这种情况如，对于这种类型的转换和explicit转换构造函数一样，必须显示指定，想隐式转换则会编译错误
SmallInt si = 3;  //正确，转换构造函数不是explicit的
si + 3;           //错误，要求隐身转换，但是类的类型转换运算符是显式的
static_cast<int>(si) +3 ;   //正确，显式调用
```

- 当一个表达式被用作条件时，编译器将显式的类型转换自动应用于它，当表达式出现在下列情况下，显式的类型转换被隐式的  执行：if、while、以及do语句的条件部分;for语句的条件表达式;！、||、&&的运算对象；？：运算符的条件表大式
 **因而一般将向bool的类型转换定义为explicit的**
