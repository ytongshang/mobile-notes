# 从"/"开始

- 目录名称严格区分大小写

- 主要常见目录的定义

  ```
  /boot    开机所需文件——内核,开机菜单及所需配置文件等
  /dev    任何设备与接口都以文件形式存放在此目录
  /etc    配置文件
  /home    用户主目录
  /bin    单用户维护模式下还能够被操作的命令
  /lib    开机时用到的函数库及/bin与/sbin下面命令要调用的函数
  /sbin    开机过程中需要的
  /media    一般挂载或删除的设备
  /opt    放置第三方的软件
  /root    系统管理员的主文件夹
  /srv    一些网络服务的数据目录
  /tmp    任何人均可使用的“共享”临时目录
  /proc    虚拟文件系统，例如系统内核，进程，外部设备及网络状态等
  /usr/local    用户自行安装的软件
  /usr/sbin    非系统开机时需要的软件/命令/脚本
  /usr/share    帮助与说明文件，也可放置共享文件。
  /var    主要存放经常变化的文件，如日志。
  /lost+found    当文件系统发生错误时，将一些丢失的文件片段存放在这里
  ```

# 物理设备命名

- 硬盘由大量的扇区组成，其中第一个扇区保存着主引导记录与分区表信息，单个扇区为512b,其中主引导要占446b,每记录一个分区要 16b,所有最多只能有4个主分区，但是可以是3个主分区加一个扩展分区，而这个扩展分区又可以分为无数个逻辑分区，就可以用逻辑分区来 完成多分区的需求了。

- Linux系统中一切都是文件，那么硬件也不外乎。既然是文件就必须有名称啦，系统内核的设备管理器(Udev)会自动将硬件名称规范起来，让我们可以通过设备名称猜出设备大致的属性以及分区信息等，Udev会一直以守护进程的形式运行并侦听来自内核发出的uevent来管理/dev目录下的设备文件

- 常见的设备命名方法

  ```
  IDE设备    /dev/hd[a-d]
  SCSI/SATA/U盘    /dev/sd[a-p]
  软驱    /dev/fd[0-1]
  打印机    /dev/lp[0-15]
  光驱    /dev/cdrom
  鼠标    /dev/mouse
  磁带机    /dev/st0或/dev/ht0(IDE设备)
  ```

- 而一台主机上可以有多块硬盘，系统便会用a-p来代表16块不同的硬盘（默认从a开始分配）且分区编号也很有讲究.主分区编号从1开始至4结束，按顺序（也可指定分配数字）。逻辑分区从编号5开始按顺序（也可指定分配数字）

- 示例：/dev/sda5

  - 首先/dev目录下的都是硬件。
  - 其次sd开头的是存储设备。
  - 然后a代表第一个被识别到的设备。
  - 最后5代表它是逻辑分区。
  - 简单来讲:"这是第一块硬盘设备中编号为5的逻辑分区"

# 文件系统与数据资料

- 常见的文件系统，Ext3, Ext4, XFS

- 因为硬盘要保存的数据实在太多了，所以一定要有个叫super block的"硬盘地图"并在上面记录着整个文件系统的信息，但绝不可能把数据直接写到这个大地图中，因为这样的话会导致它"很大"，查询与写入速度会变得非常慢，于是每个文件的权限与属性都会记录在inode table中（每个文件都会占用一个独立的inode表格，默认为128bytes），记录着：

  - 该文件的访问权限(read,write,execute)
  - 该文件的所属主与组(owner,group)
  - 该文件的大小(size)
  - 该文件的创建或状态修改时间(ctime)
  - 该文件的最后一次访问时间(atime)
  - 该文件的修改时间(mtime)
  - 文件的特殊权限(SUID,SGID,SBIT)
  - 该文件的真实数据地址(point)

- 而实际的数据则保存在block块中（大小可以是1K、2K或4K），下面的说明中，我们以4K为例。

  - 情况一：文件体积很小（1K），那么依然会占用一个block，潜在的浪费3K。
  - 情况二：文件体积很大（5K），那么会占用两个（5K-4K剩下的1K也要占用一个block）。 一个inode大小仅为128bytes（Ext3），但记录一个block则消耗4bytes，当写inode被占满后会取出一个block用于号码记录而不再是保存实际的文件系统

# 挂载

- 挂载操作指的是当用户需要使用硬盘设备或分区数据时，需要先将其与一个已存在的目录文件做关联，而这个动作就叫"挂载"

- mount命令用于挂载文件系统，格式为："mount 文件系统 挂载目录"

  - -a 挂载所有在/etc/fstab中定义的文件系统
  - -t 指定文件系统的类型

- mount命令只需要填写设备与挂载目录参数即可，一般来讲系统会自动去判断要挂载文件的类型

- 如果需要将设备"/dev/sdb2"挂载到"/backup"目录，文件格式为ext4

  ```bash
  mount /dev/sdb2 /backup
  #不用指定格式
  ```

- 使用mount命令执行挂载操作后立即就可以使用该文件系统了，但重启后则失效。如果想让重启后依然生效，我们就必须将挂载信息按照指定的格式写入到/etc/fstab文件中。 "/etc/fstab"包含着文件系统与挂载信息等内容，因为过于重要，所以只有root用户才可以编辑它

- 填写格式如下："设备文件 挂载目录 格式类型 权限选项 自检 优先级"

  - 设备文件：一般为设备的路径+名称，也可以写UUID值等。
  - 挂载目录：指定要挂载到的目录，需挂载前创建好。
  - 格式类型：即指定文件系统的格式，比如有ext3/ext4/xfs/iso9660/swap等。
  - 权限选项：默认为defaults(rw,suid,dev,exec,auto,nouser,async)，可指定acl或quota等。
  - 自检：若为1则开机后进行磁盘自检，0为不自检。
  - 优先级：若"自检"为1，则可对多块硬盘进行优先级设置。

- 定义设备"/dev/sdb2"开机自动挂载到"/backup"目录，文件格式为ext4，默认权限且无需开机自检

  ```
  /dev/sdb2  /backup ext4 defaults 0 0
  ```

- umount命令用于撤销已经挂载的设备文件，格式为："umount [挂载点/设备文件]

  ```
  unmount /dev/sdb2
  ```

# 添加硬盘设备

- 当全新安装了一块新的硬盘设备后，为了更充分、安全的利用硬盘空间首先要进行磁盘的分区，然后格式化，最后挂载使用

## 创建分区

```bash
  #查看所有硬盘，包括没有挂载
  fdisk -l

  # 输入p查看当前分区详情
  p
  Disk /dev/sdb: 5 GiB, 5368709120 bytes, 10485760 sectors
  Units: sectors of 1 * 512 = 512 bytes
  Sector size (logical/physical): 512 bytes / 512 bytes
  I/O size (minimum/optimal): 512 bytes / 512 bytes
  Disklabel type: dos
  Disk identifier: 0x0c114c38

  #输入n新建新的分区
  n
  Partition type
   p   primary (0 primary, 0 extended, 4 free)
   e   extended (container for logical partitions)

  #选择分区类型
  Select (default p):p

  #设置分区号，一般情况下是3主分区，一个逻辑分区
  分区号 (1-4, default 1): 1

  #磁盘的起始扇区，直接回车即可：
  First sector (2048-10485759, default 2048):2048

  #键入+2G，代表该分区的大小为2G
  Last sector, +sectors or +size{K,M,G,T,P} (2048-10485759, default 10485759): +2G

  #敲击字符w，将上述分区信息保存
  w
  The partition table has been altered.
  Calling ioctl() to re-read partition table.
  Syncing disks.

  #让内核同步分区信息（此步骤仅在没有找到分区设备的情况下才需要执行，非必要动作。）：
  partprobe
```

## 格式化为xfs文件系统

- 在Linux系统中用于格式化的命令是mkfs，它支持的文件类型有：cramfs,ext2,ext3,ext4,fat,msdos,xfs,btrfs,minix,vfat

- 使用方法非常的简单："mkfs.文件类型名称"，例如要格式分区为ext4，则命令为"mkfs.ext4 硬盘分区名称"

  ```bash
  #将上面的分区格式化为ext4文件系统
  mkfs.ext4 /dev/sdb1
  ```

## 将硬盘挂载在目录中

- 将硬盘设备挂载到/newFS目录

  ```bash
  mkdir /newFS
  mount /dev/sdb1 /newFS/
  ```

## 设置系统启动后自动挂载该硬盘设备

- 编缉fstab文件

  ```bash
  vim /etc/fstab
  /dev/sdb1 /newFS ext4 defaults 0 0
  # 我们现在就可以通过访问/newFS目录来使用硬盘资源
  ```

## 查看硬盘的使用情况

- df命令用于查看挂载点信息与磁盘使用量，格式为："df [选项] [文件]"

- 参数

  - -a 显示出所有的文件系统（包括虚拟的）
  - --total 展出出总体使用量
  - -h 更易读的容量格式如1K,234M,2G...
  - -i 展示出Inode的信息（默认是磁盘使用信息）
  - -T 显示出文件系统的类型

- 查看挂载信息与硬盘使用量:"df -h"

  ```
  df -h
  文件系统        容量  已用  可用 已用% 挂载点
  udev            973M     0  973M    0% /dev
  tmpfs           199M  6.3M  193M    4% /run
  /dev/sda1        18G  4.8G   12G   29% /
  tmpfs           992M  212K  992M    1% /dev/shm
  tmpfs           5.0M  4.0K  5.0M    1% /run/lock
  tmpfs           992M     0  992M    0% /sys/fs/cgroup
  tmpfs           199M   52K  199M    1% /run/user/1000
  /dev/sr0        1.4G  1.4G     0  100% /media/rancune/Ubuntu 16.04 LTS amd64
  /dev/sdb1       2.0G  3.0M  1.8G    1% /newFS
  ```

- du命令用于查看磁盘的使用量，格式为：" du [选项] [文件]"

- 参数

  - -a 评估每个文件而非目录整体占用量。
  - -c 评估每个文件并计算出总占用量总和。
  - -h 更易读的容量格式如1K,234M,2G...
  - -s 仅显示占用量总和。

- 查看newFS中文件所占空间

  ```
  du -sh /newFS/
  20K    /newFS/
  ```

# swap分区

- SWAP即交换分区是一种类似于Windows系统虚拟内存的功能，将一部分硬盘空间虚拟成内存来使用，从而解决内存容量不足的情况，因为SWAP毕竟是用硬盘资源虚拟的，所以速度上比真实物理内存要慢很多，一般只有当真实物理内存耗尽时才会调用SWAP

- 创建swap分区

  ```bash
  # 新建分区同上
  # ...

  # 修改分区类型，输入t
  t
  Selected partition 1

  # 查看可用的分区类型
  Hex code (type L to list all codes): L

  #输入swap分区类型
  Hex code (type L to list all codes): 82

  #查看分区信息
  p

  #保存
  w

  #格式化为swap分区
  mkswap /dev/sdb1

  #启动swap分区
  swapon /dev/sdb1

  # 设置为开机后自动挂载该SWAP分区设备
  vim /etc/fstab
  /dev/sdb1 swap swap defaults 0 0

  #查看当前的内存容量
  free -m
  ```

# 磁盘冗余阵列（RAID）

- Redundant Array of Independent Disks，即独立的硬盘组，作用是防止硬盘物理损坏以及增加存储设备的吞吐量。RAID常见的组合有0、1、5和10

- RAID0:需要至少两块(含)硬盘，可以有效的提高硬盘的性能和吞吐量，但没有数据的冗余和错误修复能力，将多块硬盘通过硬件或软件的方式串联在一起，成为一个大的卷集，将数据依次写入到各个硬盘中，这样性能会极大提升，但若任意一块硬盘故障则整个系统的数据都会受到破坏。

- RAID1:需要至少两块(含)硬盘，可以有效的提高数据资料的安全性和可修复性，但成本却提高了，实现原来是在数据写入硬盘时也会在另外一块闲置的硬盘上生成镜像文件，在不影响性能的情况下最大限度保证数据资料的可靠性，只要在一对镜像盘中还有一块硬盘可以使用，那么数据也不会丢失，具有很好的硬盘冗余能力，虽然对数据来讲绝对的安全，但成本却明显增加，磁盘利用率仅为50%

# 逻辑卷管理

# 磁盘容量配额

- quota的磁盘配额可以限制用户的硬盘可用空间或最大创建文件数量，并且还有软/硬限制的区别：

  - 软限制:当达到软限制时会提示用户，但允许用户在规定期限内继续使用。
  - 硬限制:当达到硬限制时会提示用户，且强制终止用户的操作

# 虚拟文件系统

- 随着计算机系统的发展产生出了众多的文件系统，为了使用户在读取或写入文件时不用关心底层的硬盘结构，于是在Linux内核中的软件层为用户程序提供了一个文件系统接口(VFS,Virtual File System)，这样就转而统一对这个虚拟文件系统进行操作啦。即实际文件系统在VFS下隐藏了自己的特性和细节，使得我们在日常使用时觉得"文件系统都是一样的"。

# 软硬方式链接

- 硬链接(hard link)可以被理解为一个"指向原始文件inode的指针"，系统不为它分配独立的inode与文件，所以实际上来讲硬链接文件与原始文件其实是同一个文件，只是名字不同。于是每添加一个硬链接，该文件的inode连接数就会增加1，直到该文件的inode连接数归0才是彻底删除。概括来说因为硬链接实际就是指向原文件inode的指针，即便原始文件被删除依然可以通过链接文件访问，但是不能跨文件系统也不能链接目录文件

- 软链接也称为符号链接（symbolic link）即"仅仅包含它索要链接文件的路径名"因此能做目录链接也可以跨越文件系统，但原始文件被删除后链接文件也将失效，如同Winodw™中的"快捷方式"

- ln命令用于创建链接文件，格式为："ln [选项] 目标"，**默认创建的是硬链接**

- 命令参数

  - -s 创建"符号链接"(默认是硬链接)
  - -f 强制创建文件或目录的链接
  - -i 覆盖前先询问
  - -v 显示创建链接的过程

- 示例

  ```bash
  #创建一个/usr/hb/的软链接
  ln -s /usr/hb/ /home/hb_link

  #删除软链接使用rm命令，注意，其末尾不能加“/”
  rm -rf /home/hb_link
  ```
