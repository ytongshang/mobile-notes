# 通用程序设计

- [将局部变量的作用域最小化](#将局部变量的作用域最小化)
- [for-each循环优先于传统的for循环](#for-each循环优先于传统的for循环)
- [了解和使用类库](#了解和使用类库)
- [如果需要精确的答案，避免使用float和double](#如果需要精确的答案避免使用float和double)
- [基本类型优先于装箱基本类型](#基本类型优先于装箱基本类型)
- [如果使用其它类型更加合适，尽量避免使用字符串](#如果使用其它类型更加合适尽量避免使用字符串)
    - [字符串类型不适合代替其它基本类型](#字符串类型不适合代替其它基本类型)
    - [字符串不适合代替枚举](#字符串不适合代替枚举)
    - [字符串不适合代替聚集类型](#字符串不适合代替聚集类型)
    - [字符串也不适合代替能力表(capabilities)](#字符串也不适合代替能力表capabilities)
    - [使用总结](#使用总结)
- [当心字符串的连接性能](#当心字符串的连接性能)
- [通过接口引用对象](#通过接口引用对象)
- [接口优先于反射](#接口优先于反射)
    - [使用反射的坏处：](#使用反射的坏处)
    - [接口与反射的使用](#接口与反射的使用)
- [谨慎地使用本地方法](#谨慎地使用本地方法)
- [谨慎地进行优化](#谨慎地进行优化)
- [遵守普通接受的命名规范](#遵守普通接受的命名规范)

## 将局部变量的作用域最小化

- 要使局部变量的作用域变小化，最有力的方法就是**在第一次使用它的地方声明它**
- **每个局部变量都包含一个显式的初始化**
- 将局部变量的作用域最小化的另一个方法就是：让方法小而集中
- **对于for循环，如果判断涉及到方法调用，并且返回值不变，应当将方法调用结果保存起来**

```java

for (int i =0, n = expensiveComputation(); i < n; ++i) {
    doSomething(i);s
}

```

## for-each循环优先于传统的for循环

- 普通for和for-each要优于while循环，因为它的可以让循环变量的作用域更小，更不容易出错
- **只要对象实现了Iterable接口，那么它就可以使用for-each循环**
- 只有在以下情况使用普通的for,一般都要优先使用for-each
    - 过滤，比如remove
    - 转换，比如对某个位置的值重新设置
    - 平行迭代

## 了解和使用类库

- java.lang
- java.util
- java.io

## 如果需要精确的答案，避免使用float和double

- 对于需要精确答案的计算任务，不要使用float和double
- 如果让系统来记录十进制小数点，可以使用BigDecimal
- 如果自己来记录小数点的话，如果数字没有超过9位十进制，可以使用int,如果数值没有超过18位十进制，
 可以使用long

## 基本类型优先于装箱基本类型

- 基本类型与装箱基本类型对比
    - 基本类型只有值，而装箱基本类型还有同一性，**也就是装箱基本类型的equals与==表示的意义是不同的**
    - 基本类型具有完备的值，但是**装箱基本类型还有无意义的null**
    - 基本类型比装箱基本类型更节省时间和空间

```java
Comparator<Integer> order = new Comparator<Integer> () }{
    public int compareTo(Integer first, Integer second) {
        return first < second ? -1 : ((first ==second) ? 0 : 1);
    }
}

// 这里因为走的是同一性判断，判断两个引用是否相同，所以返回的是1
order.compareTo(new Integer(42), new Integer(42)) = 1;
```

```java
public class Unbelievable {
    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("Unbelievable");
        }
    }
}

//在运行时会抛出NullpointerException，因为装箱基本类型在没有初始化时是null
```

- 在一项操作中混合使用基本类型和装箱基本类型时，装箱基本为型会自动拆箱

- 总结：在可以先择的时候，使用基本类型优于装箱基本类型，使用装箱基本类型
 可能出现同一性判断，NullpointerException和由于大量自动装箱和拆箱带来的性能上的问题

## 如果使用其它类型更加合适，尽量避免使用字符串

### 字符串类型不适合代替其它基本类型

- 只有当数据本质上是文本信息时，才会采用String类型，其它的时候最好使用恰当的类型
 比如如果是数值，使用int, double,BigInteger等，如果是true ,false，使用boolean
- 如果存在适当的值类型，就使用它，如果不存在，那么就应当编写一个

### 字符串不适合代替枚举

### 字符串不适合代替聚集类型

- 如果一个实体有多个组件，用一个字符串来表示这个实体通常是不恰当的，如果用字符串表示聚集类型，要访问一个域，要解析字符，过程特别的慢，也容易出错
- 正确的方法可以自定义一个类型，将各个组作为成员变量，如果可能用到map中，需要重写它的equals与hashcode方法

```java
// 如果name中间含有"#"符号,那么很容易出错
String compoundKey = name + "#" + i.next();
```

### 字符串也不适合代替能力表(capabilities)

- 如果采用下面的这种方法实现ThreadLocal,那么必须保证一个全局的命名空间，
 而且由于不同的客户端，很可能出现重复，从而出现错误

```java

public class ThreadLocal {
    private ThreadLocal() {}

    public static void set(String key, Object value);

    public static Object get(String key);
}

public class ThreadLocal {
    private ThreadLocal() {}

    public static class Key {
        Key() {}
    }

    public static void set(Key key, Object value);

    public static Object get(Key key);
}

```

### 使用总结

- **如果可以使用更加合适的类型，或者可以编写更加合适的类型，就应该避免使用String**
- **经常被错误的使用字符串类型代替的类型的基本类型，枚举类型和聚集类型**

## 当心字符串的连接性能

- 不要使用字符串连接操作符来合并多个字符串，除非性能无关紧要
- **连接多个字符串使用StringBuilder**

## 通过接口引用对象

- **如果有合适的接口类型存在,那么对于参数,返回值,变量和域来说,都应当使用接口类型进行声明**

- 使用具体类的特例
    - 如果没有合适的接口,那么使用具体的类而不是接口来引用对象完全没有问题
    - 对象属于基本类的框架,就**应当使用相关类的基类来引用这个对象,而不是用它的实现类**
    - 如果用到了类的特殊方法,那么应当使用类而不是接口,比如使用了LinkedHashMap中的相对于Map中的特殊函数

- 总结：**如果类具有合适的接口，那么用接口引用对象会使程序更加灵活；**
 **如果没有合适的接口，那么就应当使用类层次结构中提供了必要功能的最基础的类**

## 接口优先于反射

### 使用反射的坏处：

- 丢失了编译基间的类型检查
- 执行反射所要的代码非常笨拙和冗长
- 性能损失

### 接口与反射的使用

- **如果编写的类必须与编译时未知的类一起工作，如有可能，就应该仅仅使用反射机制来实例化对象**，
 **而访问对象时则使用编译时已知的某个接口或都超类**

- 常见一种情况：**如果运行时为了兼容性必须使用某个包的多个版本，一般情况下在对支持包的最小环境下对它进行编译，*并且使用最老的版本，然后以反射的方式访问任何更加新的类或着方法**

## 谨慎地使用本地方法

- 谨慎的使用native方法
- 很少情况下需要为了性能而使用native方法

## 谨慎地进行优化

>> 很多计算上的过失都被归咎于效率(没有必要达到的效率)，而不是任何其它的原因——甚至包括盲目地做傻事
>> 不要去计较效率上的一些小小的损失，在97%的情况下，不成熟的优化才是一切问题的根源
>> 在优化方面， 我们要遵守两条规则：
>> 规则1：不要进行优化
>> 规则2(仅针对专家)：还是不要进行优化——也就是说，在你还没有绝对清晰的未优化方案之前，请不要进行优化

- **要努力编写好的代码而不是快的代码，如果好的程序不够快，它的结构将使它可以得到优化**
- 好的程序
    - 好的程序设计体现了信息隐藏只要有可能，它们就会把设计决策集中在单个模块中
    - 努力避免那些限制性能的设计决策
    - 要考虑API设计决策的性能后果
- 为了获得好的性能而对API进行包装，这是一种非常不好的想法
- **每次试图做优化之前和之后，要对性能进行测量，你认为程序慢的地方可能并没有问题**
- 总结：
    - **不要费力去编写快带的程序，应该努力编写好的程序**，速度自然会随之而来，特别是在设计API，线路程协议，和永久数据格式的时候
    - 如果性能有问题：可能在性能剖析器的帮助下，找到问题根源，然后优化，而不是简单的想当然
    - **如果性能有问题：第一应当考虑算法**，再多的低层优化也无法弥由于算法不当而导致的问题

## 遵守普通接受的命名规范

- 把标准的命名规范作为一种内在的机制来看待，并且学着用它们作为第二特性
- 具体参考比如:google java code style