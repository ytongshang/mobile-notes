# 异常

- [只针对异常的情况才使用异常](#只针对异常的情况才使用异常)
    - [状态测试](#状态测试)
- [对于可恢复的情况使用受检异常，对于编程错误使用运行时异常](#对于可恢复的情况使用受检异常对于编程错误使用运行时异常)
    - [异常的分类](#异常的分类)
    - [具体使用](#具体使用)
- [避免不必要的使用受检的异常](#避免不必要的使用受检的异常)
- [优先使用标准的异常](#优先使用标准的异常)
    - [使用标装异常的好处](#使用标装异常的好处)
    - [常用的标准异常](#常用的标准异常)
- [抛出与抽象相对应的异常](#抛出与抽象相对应的异常)
- [每个方法抛出的异常都应当有文档](#每个方法抛出的异常都应当有文档)
- [在细节消息中包含能捕获失败的信息](#在细节消息中包含能捕获失败的信息)
- [努力保持失败的原子性](#努力保持失败的原子性)
    - [可变对象的失败原子性](#可变对象的失败原子性)
    - [总结](#总结)
- [不要忽略异常](#不要忽略异常)

## 只针对异常的情况才使用异常

- 在现代jvm实现上，基于异常的模式比标准模式要慢很多
- 异常应当只用于异常的情况下，它们永远不应该用于正常的控制流
- 设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常

```java
// 错误示例，不要使用异常来用于程序的控制流
try {
    int i = 0;
    while (true) {
        range[i++].climb();
    }
} catch (ArrayIndexOutOfBoundsException ignored) {
}
```

### 状态测试

- **如果类具有“状态相关”的方法**，即只有在特定的不可预知的条件下才可以被调用的方法，**这个类往往也应该有个“状态测试”的相关方法**，比如Iterator接口，有“状态相关”的方法next(),对应的也有“状态测试”的方法hasNext()
- 另一种提供单独的状态测试方法的做法是：提供一个可供识别的值，比如返回null
- “状态测试方法” VS  "可供识别的返回值"
  - 总体来说**"状态测试方法"优于"可供识别的返回值"**，更加易读和修改
  - **如果对象将在缺少外部同步的情况被并发访问，或者可以被外界改变状态**，**使用可被识别的返回值**可能是有很有必要的
  - 如果**单独的“状态测试方法”必须重复状态相关方法的工作，为了性能考虑，应当使用可被识别的返回值**

## 对于可恢复的情况使用受检异常，对于编程错误使用运行时异常

### 异常的分类

- 基类：Java.lang.Throwable
- Error错误：JVM内部的严重问题。无法恢复。程序人员不用处理。
- Exception异常：普通的问题。要求编程人员要进行处理。
- RuntimeException:也叫非受检异常(unchecked exception).这类异常是编程人员的逻辑问题。应该承担责任。Java编译器不进行强制要求处理，也就是说，这类异常在程序中，可以进行处理，也可以不处理。
- 受检异常(checked exception).这类异常是由一些外部的偶然因素所引起的。Java编译器强制要求处理。也就是说，程序必须进行对这类异常进行处理。
- 常见异常：
  - 非受检的：NullPointerException,ClassCastException,ArrayIndexsOutOfBoundsException,ArithmeticException
  - 受检：Exception,FileNotFoundException,IOException,SQLException.

### 具体使用

- **Error和RuntimeException都是不需要也不应当被捕获的异常**
- **如果期望调用者能够适当地恢复**，对于这种情况就应当**使用受检的异常**
- **对于编程错误，使用RuntimeException**
- **不要实现任何新的Error子类**
- 因为**受检的异常**往往指明了可恢复的条件，所以对于这类异常，**应当提供一些辅助方法，为恢复提供信息**,但是这些方法不应当是能过字符串解析来提供信息

## 避免不必要的使用受检的异常

- 使用受检的异常本质上并没有为程序员提供任何好处，反而需要付出努力，还使程序更为复杂
- 应当避免使用不必要的受检异常
- **受检的异常变为未受检的异常**的一种做法是：**把这个抛出异常的方法分为两个方法，其中一个方法返回一个boolean，表明这个方法是否抛出异常**,但是这种重构要注意，如果对象在缺少同步的情况被并发的访问，可能会使对象处于一种中间状态，这种重构就不合适

```java
try {
    obj.action(args);
} catch (CheckedException e) {
    // handle exception
}

if ( obj.actionPermitted(args)) {
    obj.action(args);
} else {
    // handle exception
}
```

## 优先使用标准的异常

### 使用标装异常的好处

- 与程序员已经熟悉的习惯用法一致
- 可读性会好一些
- 异常类少一些，内存占用少，但这点不重要

### 常用的标准异常

- IllegalArgumentException
- IllegalStateException
- NullPointerException
- IndexOutOfBoundsException
- ConcurrentModificationException
- UnsupportedOperationException

- 如果某个java的标准异常可以满足你的需求，直接使用，但要注意抛出异常的条件与该异常的文档中的描述是否一致
- 如果想要增加异常中有助于失败捕获的信息，可以放心把现有异常子类化

## 抛出与抽象相对应的异常

- 更高层的实现应当捕获低层的异常，然后抛出可以按照高层抽象进行解释的异常
- **如果不能阻止或者处理来自更低层的异常，一般情况是异常转译**

```java
try {
    // use lower-level abstraction to do our bidding
} catch (LowerLevelException e) {
    throw new HigherLevelException(...);
}
```

- **使用 public Throwable(Throwable cause)  的构造函数和 public Throwable initCause(Throwable throwable) 构成异常链**

```java
try {
    //...
} catch (LowerLevelException e) {
    throw new HigherLevelException(cause);
}
```

## 每个方法抛出的异常都应当有文档

- **始终要单独的声明受检的异常**，并且利用javadoc的@throw标记，准确地记录下抛出每个异常的条件
- **对于方法可能抛出的未受检异常**，如果**将这些异常信息很好地组织成列表文档**，就可以有效地描述出这个方法被成功执行的前置条件
- **使用javadoc的@throw标签记录下可能抛出的每个未受检异常**，但是**不要使用throws关键字将未受检的异常包含在方法的声明中**
- **如果一个类中的很多方法由于同样的原因而抛出同一个异常，在该类的注释文档中对这个异常建立文档，这是可以接受的**

## 在细节消息中包含能捕获失败的信息

- **异常的toString方法应当尽可能的返回更多的有关失败的信息**
- 为了捕获失败，异常细节信息应该包含所有”对异常有贡献“的参数和域的值

## 努力保持失败的原子性

- 一般而言，**失败的方法调用应该使对象保持在被调用之前的状态，具有这种属性被称为失败原子性**
- 最简单的办法莫过于设计一个不可变的对象，在失败前后对象不变

### 可变对象的失败原子性

- **对于可变对象**，获取失败原子性的最常见的办法是，**在执行操作之前检查参数的有效性，这可以使得对象的状态被改变之前，先抛出适当的异常**

```java
public Object pop() {
    if (size  == 0) {
        throw new EmptyStatckException();
    }
    Object result = element[--size];
    element[size] = null;
    return result;
}
```

- 第二种方法，**在对象的临时拷贝上执行操作，当操作完成后再用临时拷贝中的结果代替对象的内容**，这样成功了没有问题,如果失败了，那么对象也不变改变，比如Collections.sort(),先把它放到一具数组中，既减少了开销，又增加了一项优势,即使失败，也能保证输入列表保持原样
- 最后一种方法，编写一段恢复性代码，用它来拦截操作过程中发生的失败，以及使对象回滚到操作开始之前的状态上,这种主要用于永久性的（基于磁盘）的数据结构

### 总结

- 作为方法规范的一部分，**产生的任何异常都应该让对象保持在方法调用之前的状态，如果违反这条规范，API文档应当清楚的指明对象处于什么样的状态**

## 不要忽略异常

- 空的catch块会使异常达不到应有的目的，因为这会导致程序在遇到错误的情况下悄然的执行下去
- 如果忽略了异常，应当有说明为什么可以忽略
