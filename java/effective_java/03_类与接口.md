# 类与接口

* [使类与成员的可访问性最小化](#使类与成员的可访问性最小化)
  * [类与接口的可访问性](#类与接口的可访问性)
  * [类成员的可访问性](#类成员的可访问性)
* [在公有类中使用访问方法而不是公有域](#在公有类中使用访问方法而不是公有域)
* [使可变性最小化](#使可变性最小化)
  * [不可变类](#不可变类)
  * [可变性最小化](#可变性最小化)
* [复合优先于继承](#复合优先于继承)
  * [继承的劣势](#继承的劣势)
  * [使用复合](#使用复合)
  * [复合 VS 继承](#复合-vs-继承)
* [要么为继承设计，并提供文档，要么就禁止继承](#要么为继承设计并提供文档要么就禁止继承)
  * [专为继承而设计的类](#专为继承而设计的类)
  * [最佳实践](#最佳实践)
* [接口优先于抽象类](#接口优先于抽象类)
  * [接口相比抽象类的优势](#接口相比抽象类的优势)
  * [骨架实现](#骨架实现)
  * [模拟多重继承](#模拟多重继承)
  * [简单实现](#简单实现)
  * [接口相对于抽象类的缺点](#接口相对于抽象类的缺点)
* [接口只被用来类型定义](#接口只被用来类型定义)
* [类层优先于标签类](#类层优先于标签类)
  * [标签类](#标签类)
  * [将标签类转换为类层次](#将标签类转换为类层次)
  * [相比较标签类的优点](#相比较标签类的优点)
* [用函数对象表示策略](#用函数对象表示策略)
  * [函数对象](#函数对象)
  * [函数对象的优点以及使用技巧](#函数对象的优点以及使用技巧)
* [优先考虑静态成员类](#优先考虑静态成员类)
  * [嵌套类](#嵌套类)
  * [嵌套类的使用技能](#嵌套类的使用技能)

## 使类与成员的可访问性最小化

* 原则：**尽可能使类或类的成员不被外界访问**

### 类与接口的可访问性

* 对于顶层的类与接口，访问性只能是public或都包访问级别的
* 类与接口，如果它是public的，那么它就是包的导出api的一部分，那么有责任永远的支持它
* 但是如果它是包访问级别的的，那么它就是包的实现的一部分，以后对这部分修改、替换、删除，都不用担心现有的客户端程序
* 如果一个包访问级别的类只在一个类的内部被用到，那么应当考虑使它成为那个唯一使用它的那个类的的私有嵌套类

### 类成员的可访问性

* private
* 包访问级别
* protected,**子类以及声明该成员的包内部的任何类也可以访问这个成员，protected具有包访问权限的一切特性**
* public
* 一般情况下，都会将成员变成私有的，**只有当包内的另一个类真正需要访问这个成员时，才将其声明为包访问级别的**
* 对于**公有类的protected成员，其也是公有类的导出API的一部分**，必须永远得到支持，所以**protected的成员应当尽可能的少用**
* 为了测试，可以将private成员变成包访问级别的，但是绝对不能变成不能高于包访问级别
* **public类的成员变量，绝不能是公有的**，如是成员变量是非final的，或者是一个指向可变对象的final引用，那么一旦使这个成员变量变成公有的，那么就放弃了对
  存储在这个成员变量中的值进行限定的方法，**包含公有可变成员变量的类绝对不是线程安全的**
* 对于static成员变量，上述对public成员变量的规则同样适用。
* 对于static成员变量，只有static final可以声明为public这一种例外，**static final的成员变量要么包含基本类型，要么包含指向不可变对象的引用**，
  **如果final成员变量包含可变对象的引用，那么它便具有final成员变量的所有缺点，引用本身不可变，但是引用的对象却可以被修改**
* 长度非0的数组总是可变的，所有类具有public static final数组成员变量，或者返回这种成员变量的访问方法，这几乎总是错误的
  解决办法是返回对象的clone,或都返回对应的不可修改的collection

```java
// public static final 数组总是有问题的
public static final Thing[] VALUES = {...};

private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES);)

private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

## 在公有类中使用访问方法而不是公有域

* **对于public类，对于类中的成员变量，应当使用public访问方法，而不是直接将成员变量设为public**，
  其原因是使用public方法访问变量，可以保留将来改变该类的内部表示方法的灵活性
* 而对于包访问权限的类，或者私有的嵌套类，直接暴露它成员变量，并没有本质上的错误
* 对于公有类，可以使用public static final的成员变量，但是要求该成员变量要么是基本类型，或者指向不可变的对象，
  使用public static final 变量指向不可变的对象造成的危害要小一些
* 结论：**公有类永远不应当暴露可变的成员变量，在特定情况下，可以暴露不变变的对象（比如static final对象）**，
  **对于包访问级别或者私有的嵌套类直接暴露成员变量，是可以接受的**

## 使可变性最小化

### 不可变类

* 定义：实例不能被修改的类，每个实例中包含的所有信息都必须在创建该对象的时候提供，并在整个对象的生命周期内固定不变
* 不可变对象的原则

  * 所有的成员变量都是私有的
  * 所有的成员变量都是final的
  * 不要提供任何修改对象成员变量的方法\(实际上是没有一个方法能够使对象采生外部可见的改变\)
  * 保证类不会被扩展\(**类被声明为final,或者所有的构造函数变成private,包访问级别的，并声明公有的静态工厂方法来代替公有的构造器**\)
  * **确保对于任何可变组件的互斥访问，比如类中的指向可变对象的域，则必须确保该类的客户端无法获得这类对象的引用，**
    **也不要用客户端提供的对象来初始化可变对象的域，也不要有任何方法返回这类对象的引用**

* 不可变对象的特点：

  * 对于可变对象有一些函数类操作，**返回值是一个新的对象，而不是在原先的对象上修改状态**，比如String类对象
  * 不可变对象本质上线程安全的，它们不要求同步
  * 不可变对象可以自由的被共享，不可变类应当充分利用这种优势，鼓励客户端尽可能的重有现有的对象，一种常用的方法定义常用对象
    的public static final对象，或者采用静态工厂的方法利用缓存来返回对象（比如Collections.emptyList\(\)等）
  * 不可变对象可以自由地被共享，因而不需要为不可变对象提供拷贝构造函数，不需要提供保护性拷贝（返回原先对象的拷贝而不是原先对象）
  * 不可变对象不仅可以共享不可变对象，还可以共享它们内部的信息（比如BigInteger的negate\(\)方法的返回值）

* 缺点：对于每个不同的值都需要一个单独的对象，可能在性能有所降低，解决办法一个是预测会有哪些操作，然后将它们作为基本类型提供，  
  另一种解决方法就是提供不可变对象的可变适配类（比如String和StringBuilder）

* 如果让不可变对象实现序列化，并且它包含一个或者多个指向可变对象的成员变量，那么必须显示提供readObject或者readResollve,或者使用  
  ObjectOutputStream.writeUnshared和ObjectInputStream中的readUnShared。

### 可变性最小化

* 如果没法使类变成不可变的，那么就应当尽可能的限制它的可变性，从而减少对象可以存在的状态数
* 除非有理由让成员变量变成非final的，那么成员变量就应当是final的
* 坚决不要为每一个get方法设置一个set方法
* **一般不要为对象提供可以重新初始化的方法**（这种方法是对象可以被重用，就好像这个对象是由另一个不同的初始状态构造出来的一样，
  因为在性能上重新初始化并没有带来很大的优势

## 复合优先于继承

### 继承的劣势

* 类继承，与方法调用不同，继承打破了封装性
* 导致子类脆弱的一个原因，就是我们在重写超类的方法时，**依赖于我们对于超类方法实现细节的了解**
  另一方面，哪怕我们在子类中只增加新的方法而不重写超类方法，也有可能因为将来超类新增与子类同签名的方法而出现问题

### 使用复合

* 不扩展现有的类，而是在**新的类增加一个引有现有类实例的私有成员变量，然后将私有成员变量的功能转发出去**。
* 复合更好的形式是，**新增的类和想要扩展的类实现了同样的接口**，就是一个“装饰者模式”

### 复合 VS 继承

* 使用复合而不是继承，可以**避免暴露类具体的实现细节**
* 复合类可以隐藏想要扩展的类中有缺陷的API
* **只有当子类与超类之间确实存在子类型关系的时候，才使用继承**
* 当超类与子类在不同的包时，又或者超类并不是为了继承而设计的，使用继承会导致新的类很“脆弱”
* 使用复合而不是继承，特别是包装类与原来的类实现相同的接口时，会使包装类更加健壮，也更加的强大

## 要么为继承设计，并提供文档，要么就禁止继承

### 专为继承而设计的类

* 该**类必须有文档描述它可以被Override的方法的自用性**，也就是对于每个public或者protected或构造函数，
  它文档必须指明该方法或者构造函数调用了哪些可以Override的方法，是以什么顺序用的，每个调用的结果又是如何影响
  后续的处理结果的。
* **类必须通某种方式提供合适的钩子**，以使能够进入到它的内部工程流程中，这种形式可以是精心选择的protected方法或者域
* 对于可能被广泛使用的专为继承的类，对于文档中所说明的自用性，以及对于其protected的方法和成员变量所隐含的实现策略，
  实际上已经**做了永久承诺**，所以在发布类之前必须编写类进行测试
* 对于专为继被而生的类，**构造函数中绝对不能调用可以被Override的方法，也就是构造函数中只能调用final方法**
* 对于专为继被而生的类，**如果实现了Serializable或者Cloneable接口，那么无论是clone\(\)还是readObject\(\)方法，**
  **无论直接还是间接都不能够调用可以被Override的方法**
* 对于专为继承而生的类，如果**继承了Serializable,如果类有一个readResolve或者有writeReplace,那么这两个方法必须是protected,不能是private的**，
  否则子类会忽略掉这两个类

### 最佳实践

* **对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化**，原理是final类，或者包访问级别，private的构造函数，并提供静态工厂方法
* **使用复合而非继承，使用包装类**
* 对于一般的**可以被继承却又没有专门为子类化设计的类来说，最好不要调用它的任何可能被Override的方法**，解决方法一种手动是消除类中可Override方法的自用性，
  另外一种方法就是**将每个可以被Override方法中的代码转移到一个private的辅助方法中，并且让每个可以被Override的方法调用它的私有辅助方法**，
  然后**用“直接调用可以被Override的私有辅助方法”来代替“可Override方法的自用调用”**

## 接口优先于抽象类

### 接口相比抽象类的优势

* 现有的类可以很容易的被更新，以实现新的接口
* **接口是混合类型的理想选择**，类除了是它继承的基本类型外，还可以是其它类型
* **接口允许我们构造非层次结构的类型框架**，很多时候，有些事物不能整齐的组织成一个严格的层次结构，使用接口更加合理，
  比如作曲与歌唱，不是所有的都会作曲，也不是所有的都会歌唱，但是也有者都会存在的情况，继承不同的接口，更加合理

### 骨架实现

* 通过对你导出的每个重要接口都提供一个抽象的骨架实现类（**一般情况下是一个抽象类**），可以把接口和抽象类的优点结合起来，比如SimpleGestureListener
  如果设计得当，可以让程序员很容易提供他们自己的实现
* 骨架实现它为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所特有的严格限制
* 骨架实现实际上是为了继承的目的而设计的

### 模拟多重继承

* 一个类实现一个接口，这个类又把对接口方法的调用，转发到一个内部私有类的实例上，这个内部私有类又扩展了骨架实现，与装饰者模式密切相关

### 简单实现

* 实现了接口，但又不是抽象的，它是最简单的可能的有效实现，可以原封不动的使用，也可以将它子类化

### 接口相对于抽象类的缺点

* **抽象类的演变相对于接口的演变要容易的多**，比如接口新增了一个方法，那么所有它的子类都必须要修改代码，实现新的方法
  而**抽象类可以随便增加方法，只要在抽象类中包含默认的合理实现即可**
* **接口通常是定义允许多个实现的类型的最佳途径**
* 如果**类的演变性比灵活性和功能性更加重要的话**，也就是超类可能多次修改的话，**抽象类比接口更加合理**
* 接口必须谨慎的定义，并且**如果设计了一个重要的接口，一般情况下就要提供骨架实现**，
  **这样当接口变化时，一般修改骨架实现即可，不用修改所有使用了骨架实现的代码**

## 接口只被用来类型定义

* **接口只用来定义类型**，类实现接口后，接口就可以充当引用这个类的实例的类型
* **不要使用常量接口**，也就是在一个接口中只提供了static final 的成员变量，而没提供方法
* **常量**最好**使用不能被初始化的工具类来提供**，如果工具类分为很多具体的类型的话，可以使用public static final内部类来区别

## 类层优先于标签类

### 标签类

* 就是在一个类的内部有一个标签成员tag, tag成员如果是不同类型的话，使用不同的成员变量,其它很多成员用不到
* 标签类过于冗余，容易出错，并且效率低下

```java
class Figure {
  enum Shape {
    RECTANGLE,CIRCLE
  };

  final Shape shape;

  //只有当Shape是RECTANGLE才会用到
  double width;
  double height;

  //只有当Shape是CIRCLE才会用到
  double radius;

  Figure(double radius) {
    shape = CIRCLE;
    this.radius = radius;
  }

  Figure(double width, double height) {
    shape = RECTANGLE;
    this.width = width;
    this.height = height;
  }

  double area() {
    switch (shape) {
      case RECTANGLE:{
        return width * height;
      }
      case CIRCLE:{
        return Math.PI*radius*radius;
      }
      default:{
        throw new AssertionError();
      }
    }
  }
}
```

### 将标签类转换为类层次

* 首先为标签类中每个方法都定义一个包含抽象方法的抽象类，并且包含公共的成员变量
* 使用继承实现类层次

```java
abstract class Figure {
  abstract double area();
}

class Circle extends Figure {
  final double radius;

  Circle(double radius) {
    this.radius = radius;
  }

  @Override
  double area() {
    return Math.PI*radius*radius;
  }
}

class Rectangle extends Figure {
  final double width;
  final double height;

  Rectangle(double width, double height) {
    this.width = width;
    this.height = height;
  }

  @Override
  double area() {
    return width * height;
  }
}
```

### 相比较标签类的优点

* 代码清楚
* 每个类都只有自己的数据，不受其它数据的影响
* 不太可能遗漏switch语句
* 自己扩展起来方便
* 可以更好的反应类的层次结构和关系，有利于编译期境进行类型检查

## 用函数对象表示策略

### 函数对象

* 类似于C++中的函数指针
* 不包含成员变量，只表示一个操作

```java
class StringLengthComparator {
  public int compare(String s1, String s2) {
    return s1.length() - s2.length();
  }
}
```

### 函数对象的优点以及使用技巧

* 一般情况下，**常与策略设计模式**一起使用
* **一般还要设计一个策略接口**
* 很多不同的地方，可以使用同一个对象
* 如果**只在一个地方使用，一般用匿名对象**
* **如果有多个地方使用，一般将类实现为私有的静态成员类，并通过公有的静态final成员变量导出**

```java
public interface Comparator<T> {
  int compare(T t1, T t2);
}

class Host {

  private static class StrLenCmp implements Comparator<String> {

    @Override
    public int compare(String s1, String s2) {
       return s1.length() - s2.length();
    }
  }

  public static final Comparator<String> STRING_LENGTH_COMPARATOR = new StrLenCmp();
}
```

## 优先考虑静态成员类

### 嵌套类

* 静态内部类，非静态内部类，匿名类，局部类
* 静态内部类不包含外部类的引用
* 非静态内部类包含外部引用
* 匿名类除了在声明时，无法实例化，不能使与类名有关的行为（比如instanceOf）,不能实现类，接口，也不能扩展类，也不能拥有静态成员
  也不能太复杂，否则会影响阅读，一般情况下最好不要超过10行,常用的比如函数对象，回调等
* 局部类，出现在可以定义局部变量的地方，生命周期也一样，可以有名字，可以被重复使用，在非静态环境下有外部类的引用，不能有静态成员，不能太复杂

### 嵌套类的使用技能

* 如果一个类太长了，或者在方法之外仍然可见，考虑成员类
* 优先考虑静态成员类,只有类的每一个实例都需要一个指向其外围实例时，才使用非静态成员类
* 如果这个类属于一个方法的内部，并且只有一个地方需要它，并且已经有一个预置的类型可以说明这个类的特点，使用匿名名，否则使用局部类



