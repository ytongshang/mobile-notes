# Hash表

## 原理

-   利用数组支持按下标随机访问的特性，通过散列函数将元素的键值映射为下标，然后将数据存储在数组对应下标的位置
-   查找元素时，用同样的散列函数，将健值转换为数组下标，从数组对应下位位置读取数据

## 散列函数

-   要求
    -   散列值非负整数
    -   key1 == key2,那么 hash(key1) = hash(key2)
    -   key1 != key2,那么 hash(key1) != hash(key2)
-   第 3 个条件可能会有问题，因为会有散列冲突

## 散列冲突

### 装载因子

-   装载因子越大，说明空闲位置越少，冲突越多，散列性能会下降

### 开放寻址法

![开放寻址法](./../image-resources/algo/散列冲突开放寻址法.jpg)

#### 插入

-   key -> hash(key)
-   如果 hash(key)对应的下标没有数据，插入数据
-   如果 hash(key)对应的下标有数据，那么线性向后探测找到一个空闲的位置，插入数据
-   如果找到最后也没有空闲位置，那么从头开始查找空闲位置，然后插入数据

### 查找

-   key->hash(key)
-   比较 hash(key)下标对应的元素与查找元素，如果相等，返回
-   如果不相等，向后顺序查找
-   如果遍历到数组中的空闲位置，还没有找到，说明元素不在散列表中
-   **线性探测中，如果找到一个空闲位置，就认定散列表中不存在这个元素**

#### 删除

-   由于线性探测中，如果找到一个空闲位置，就认定散列表中不存在这个元素，**所以删除时，不能单纯的把要删除的元素置空**
-   删除时，将元素标记为 deleted,当线性查找时遇到标记为 deleted 的元素时，并不停下来，继续向下探测

#### 线性探测

-   每次探测步长为 1

#### 二次探测

-   每次探测步长为为 hash(key) + 0 , hash(key) + 1, hash(key) + 4, hash(key) + 9, hash(key) + 16 等平方步长

#### 双重散列

-   一组散列函数,hash1(key), hash2(key), hash3(key)
-   先用 hash1(key)，如果被占用，再用 hash(key2), 如果被占用，hash3(key)

### 链表法

![链表法](./../image-resources/algo/散列冲突链表法.jpg)

## 设计散列函数

-   散列函数不能太复杂
-   散列函数生成的值要尽可能随机并且均匀分布

## 装载因子过大

-   动态散列表，如果装载因子过大了，需要动态扩容
-   如果对于空间特别敏感，当装载因子小于某个值后，启动动态缩容
-   如果数据量很大，进行动态扩容时，一次性拷贝数据的效率是很低的
    -   可以将扩容操作穿插在插入的过程中分批完成
    -   当装载因子过大时，我们并不将老数据迁移到新散列表中
    -   新数据插入时，新数据插入到新散列表中，并且从老的散列表中拿出一个数据放入到新的散列表中
    -   重复操作，直到所有数据都迁移到新散列表中

## 选择冲突解决办法

### 使用开放寻址法

-   只适用于装载因子小于 1 的情况，接近 1 时，有大量的散列冲突，导致大量的探测和再散列
-   开放寻址法适用于 **数据量经较小， 装载因子小的时候**

### 使用链表法

-   链表法相对开放寻地法，对大装载因子的容忍度更高，只要散列函数的值随机均匀，即使装载因子变成 10，也就是链表的长度变长而已，虽然查找效率下降，但是还是比顺序查找要快
-   链表如果存储的是大对象，也就是说要存储的对象的大小远远大于一个指针的大小，那么指针的内存消耗在大对象面前就可以忽略了
-   **对链表法稍加改造，将链表法的链表改造成其它高效的数动态数据结构，比如跳表，红黑树，即使出现散列冲突，极端情况下在一个桶内，查寻也就变成了 O(logn)**
-   **基于链表的散列冲突解决办法适用于大对象，大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如使用红黑树代替链表**

## Hash算法

-   将任意长度的二进制串转变为固定长度的固定值串
    -   不能反向推导
    -   数据敏感，修改一bit,也会让hash值大不相同
    -   散列冲突概率要小
    -   执行效要快，针对较长文本，也能很快计算出hash值
